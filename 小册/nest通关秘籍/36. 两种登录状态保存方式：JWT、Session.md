# 两种登录状态保存方式：JWT、Session

基本所有网站都有登录功能，登录之后再次请求依然是登录状态。

但 http 是无状态的，也就是说上一次请求和下一次请求之间没有任何关联。

那如何实现的这种登录状态的保存呢？

这个问题的解决有两种方案：

- 服务端存储的 session + cookie 的方案
- 客户端存储的 jwt token 的方案

但这两种方式也都有各自的缺点。

## 服务端存储的 session + cookie

给 http 添加状态，那就给每个请求打上个标记，然后在服务端存储这个标记对应的数据。这样每个被标记的请求都可以找到对应的数据，自然可以做到登录、权限等状态的存储。

这个标记应该是自动带上的，所以 http 设计了 cookie 的机制，在里面存储的数据是每次请求都会带上的。

然后根据 cookie 里的标记去查找的服务端对应的数据叫做 session，这个标记就是 session 的 id。

![](./images/36.%20两种登录状态保存方式：JWT、Session/session+cookie.awebp)

如图，因为请求自动带上 cookie，那两次请求就都可以找到 id 为 1 对应的 session，自然就知道当前登录的用户是谁，也可以存储其他的状态数据。

这就是 session + cookie 的给 http 添加状态的方案。

大家觉得这种方案有问题么？

有问题，而且问题还挺多的。

最大的一个问题就是臭名昭著的 CSRF（跨站请求伪造）：

## CSRF

因为 cookie 会在请求时自动带上，那你在一个网站登录了，再访问别的网站，万一里面有个按钮会请求之前那个网站的，那 cookie 依然能带上。而这时候就不用再登录了。

这样万一点了这个按钮之后做了一些危险的操作呢？

是不是就很危险。

而且一般这种利用 CSRF 漏洞的网站都会伪装的很好，让你很难看出破绽来，这种网站叫做钓鱼网站。

为了解决这个问题，我们一般会验证 referer，就是请求是哪个网站发起的，如果发起请求的网站不对，那就阻止掉。

但这样依然不能完全解决问题，万一你用的浏览器也是有问题的，能伪造 referer 呢？

所以一般会用随机值来解决，每次随机生成一个值返回，后面再发起的请求需要包含这个值才行，否则就认为是非法的。

这个随机值叫做 token，可以放在参数中，也可以放在 header 中，因为钓鱼网站拿不到这个随机值，就算带了 cookie 也没发通过服务端的验证。

这是 session + cookie 这种方案的一个缺点，但是是有解决方案的。

它还有别的缺点，比如分布式的时候：

## 分布式 session

session 是把状态数据保存在服务端，那么问题来了，如果有多台服务器呢？

当并发量上去了，单台服务器根本承受不了，自然需要做集群，也就需要多台服务器来提供服务。

而且现在后端还会把不同的功能拆分到不同的服务中，也就是微服务架构，自然也需要多台服务器。

那不同服务器之间的 session 怎么同步？

登录之后 session 是保存在某一台服务器的，之后可能会访问到别的服务器，这时候那台服务器是没有对应的 session 的，就没法完成对应的功能。

这个问题的解决有两种方案：

一种是 session 复制，也就是通过一种机制在各台机器自动复制 session，并且每次修改都同步下。这个有对应的框架来做，比如 java 的 spring-session。

各台服务器都做了 session 复制了，那你访问任何一台都能找到对应的 session。

还有一种方案是把 session 保存在 redis，这样每台服务器都去那里查，只要一台服务器登录了，其他的服务器也就能查到 session，这样就不需要复制了。

分布式会话的场景，redis + session 的方案更常用一点。

还好，session 在分布式时的这个问题也算是有解决方案的。

但你你以为这就完了么？session + cookie 还有跨域的问题：

## 跨域

cookie 为了安全，是做了 domain 的限制的，设置 cookie 的时候会指定一个 domain，只有这个 domain 的请求才会带上这个 cookie。

而且还可以设置过期时间、路径等：

那万一是不同 domain 的请求呢？也就是跨域的时候，怎么带 cookie 呢？

a.xxx.com 和 b.xxx.com 这种还好，只要把 domain 设置为顶级域名 xxx.com 就可以了，那二三级域名不同也能自动带上。

但如果顶级域名也不同就没办法了，这种只能在服务端做下中转，把这俩个域名统一成同一个。

上面说的不是 ajax 请求，ajax 请求有额外的机制：

ajax 请求跨域的时候是不会挟带 cookie 的，除非手动设置 withCredentials 为 true 才可以。

而且也要求后端代码设置了对应的 header：

Access-Control-Allow-Origin: "当前域名";
Access-Control-Allow-Credentials: true

这里的 allow origin 设置 \* 都不行，必须指定具体的域名才能接收跨域 cookie。

这是 session + cookie 方式的第三个坑，好在也是有解决方案的。

## 小结

session + cookie 的给 http 添加状态的方案是服务端保存 session 数据，然后把 id 放入 cookie 返回，cookie 是自动携带的，每个请求可以通过 cookie 里的 id 查找到对应的 session，从而实现请求的标识。这种方案能实现需求，但是有 CSRF、分布式 session、跨域等问题，不过都是有解决方案的。

session + cookie 的方案确实不太完美，我们再来看另一种方式怎么样：
